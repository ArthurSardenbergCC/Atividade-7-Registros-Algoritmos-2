Exercícios da atividade 7 - Registros (structs) - páginas 60 e 61

Letra A
1) Código sem o uso de vetores 

#include <iostream>
using namespace std;

typedef struct{
    int hora;
    int minutos;
} horario;

typedef struct{
    int dia;
    int mes;
    int ano;
} momento;

typedef struct{
    horario h_comp;
    momento d_comp;
    string atividade; 
} compromisso;

int main(){
    compromisso reuniao = {8, 30, 25, 8, 2025, "Planejamento"};
    compromisso medico = {10, 40, 26, 8, 2025, "Consulta"};
    compromisso limpeza = {14, 45, 27, 8, 2025, "Limpar apartamento"};
    
    cout << reuniao.h_comp.hora << " " << reuniao.h_comp.minutos << " " << reuniao.d_comp.dia << " " << reuniao.d_comp.mes << " ";
    cout << reuniao.d_comp.ano << " " << reuniao.atividade << endl;
    cout << medico.h_comp.hora << " " << medico.h_comp.minutos << " " << medico.d_comp.dia << " " << medico.d_comp.mes << " ";
    cout << medico.d_comp.ano << " " << medico.atividade << endl;    
    cout << limpeza.h_comp.hora << " " << limpeza.h_comp.minutos << " " << limpeza.d_comp.dia << " " << limpeza.d_comp.mes << " ";
    cout << limpeza.d_comp.ano << " " << limpeza.atividade << endl;    
    return 0;
}

2) Código com o uso de vetores

#include <iostream>
#define N 3
using namespace std;

typedef struct{
    int hora;
    int minutos;
} horario;

typedef struct{
    int dia;
    int mes;
    int ano;
} momento;

typedef struct{
    horario h_comp;
    momento d_comp;
    string atividade; 
} compromisso;

void preencher (compromisso *informacoes){
    cin >> informacoes->h_comp.hora >> informacoes->h_comp.minutos >> informacoes->d_comp.dia >> informacoes->d_comp.mes;
    cin >> informacoes->d_comp.ano >> informacoes->atividade;
    cin.get();
}

void impressao (compromisso *informacoes){
    cout << informacoes->h_comp.hora << " " << informacoes->h_comp.minutos << " " << informacoes->d_comp.dia << " ";
    cout << informacoes->d_comp.mes << " " << informacoes->d_comp.ano << " " << informacoes->atividade << endl;
}

int main(){
    int i = 0;
    compromisso detalhes [N];
    for (i = 0; i < N; i++){
        preencher (&detalhes[i]);
    }
    for (i = 0; i < N; i++){
        impressao (&detalhes[i]);
    }    
    return 0;
}

Cuidado! A palavra "data" é reservada no C++. Utilizá-la como um registro irá causar um erro de compilação por ambiguidade. Note que esse erro não acontecerá em todos os compiladores, mas foi verificado no Online GDB.

Lembre-se! Um vetor com 2 posições terá os índice 0 e 1. Não coloque a condição "i <= N" em laços de repetição nesses casos, pois isso acarretará em um erro de acesso a posições fora do vetor (erro 134 ou 139). 


Letra B
1) Código com a soma feita na função principal
#include <iostream>
#define N 3
using namespace std;

typedef struct{
    float x;
    float y;
    float z;
} vetor;

void entrada_vetor (vetor *componentes){
    cin >> componentes->x >> componentes->y >> componentes->z;       
}

void impressao_soma (vetor *componentes){
    cout << componentes->x << " " << componentes->y << " " << componentes->z << " " << endl;
}

int main(){
    int i = 0;
    vetor quantidade [N];
    
    for (i = 0; i < N - 1; i++){
        entrada_vetor (& quantidade [i]);
    }

    for (i = 0; i < N - 1; i++){
        quantidade [N - 1].x += quantidade [i].x;
        quantidade [N - 1].y += quantidade [i].y; 
        quantidade [N - 1].z += quantidade [i].z;  
    }
    
    impressao_soma (& quantidade [N - 1]);

    return 0;
}

Comentários:
O operador "." é chamado de operador de associatividade, enquanto o "->" é chamado de operador seta.


2) Código feito com uma função soma dedicada
#include <iostream>
#define N 3
using namespace std;

typedef struct{
    float x = 0;
    float y = 0;
    float z = 0;
} vetor;

void entrada_vetor (vetor *componentes){
    cin >> componentes->x >> componentes->y >> componentes->z;       
}

void soma_vetor (vetor *componentes, vetor *componentes_soma){
    componentes_soma->x += componentes->x;
    componentes_soma->y += componentes->y; 
    componentes_soma->z += componentes->z; 
}

void impressao_soma (vetor *componentes){
    cout << componentes->x << " " << componentes->y << " " << componentes->z << " " << endl;
}


int main(){
    int i = 0;
    vetor quantidade [N];
    
    for (i = 0; i < N - 1; i++){
        entrada_vetor (& quantidade [i]);
    }
    
    for (i = 0; i < N - 1; i++){
        soma_vetor (& quantidade [i], & quantidade [N - 1]);
    }
    
    impressao_soma (& quantidade [N - 1]);

    return 0;
}


Letra C
#include <iostream>
#define N 3
using namespace std;

typedef  struct{
    float real = 0;
    float imaginaria = 0;
} complexo;

void entrada_complexos (complexo *componentes){
    int i = 0;
    cin >> componentes->real >> componentes->imaginaria;   
}

void soma (complexo *componentes, complexo *resultado){
    resultado->real += componentes->real;
    resultado->imaginaria += componentes->imaginaria;
}

void subtracao (complexo *componentes1, complexo *componentes2, complexo *resultado){
    resultado->real = componentes1->real - componentes2->real;
    resultado->imaginaria = componentes1->imaginaria - componentes2->imaginaria;
}

void multiplicacao (complexo *componentes1, complexo *componentes2, complexo *resultado){
    resultado->real = componentes1->real * componentes2->real - componentes1->imaginaria * componentes2->imaginaria;
    resultado->imaginaria = componentes1->real * componentes2->imaginaria + componentes1->imaginaria * componentes2->real;
}

int main(){
    int i = 0;
    complexo numeros [N];
    
    for (i = 0; i < N - 1; i++){
        entrada_complexos (& numeros [i]);
    }
    
    for (i = 0; i < N - 1; i++){
        soma (& numeros [i], & numeros [N - 1]);
    }
    
    cout << "Soma: " << numeros [N - 1].real << " + (" << numeros [N - 1].imaginaria <<  "i)" << endl; 
    
    subtracao (& numeros [0], & numeros [1],  & numeros [N - 1]);
    
    cout << "Subtração: " << numeros [N - 1].real << " + (" << numeros [N - 1].imaginaria <<  "i)" << endl; 
    
    multiplicacao (& numeros [0], & numeros [1],  & numeros [N - 1]);
    
    cout << "Multiplicação: " << numeros [N - 1].real << " + (" << numeros [N - 1].imaginaria <<  "i)" << endl;

    return 0;
}


Letra D

#include <iostream>
#include <vector>
#define N 4
using namespace std;

typedef struct {
    string nome;
    vector <string> valor = {"A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"};  
} baralho;

int main(){
    baralho naipes [N];
    vector <string> auxiliar;
    int x = 0, i = 0, y = 0;
    string t;
    
    naipes [0].nome = "paus";
    naipes [1].nome = "ouros";
    naipes [2].nome = "copas";
    naipes [3].nome = "espadas";
    
    srand (time (NULL));
    
    for (i = 0; i < 10; i++){
        x = rand () % 4;
        y = rand () % 13;
        //vector <string> auxiliar = naipes [x].valor;
        while (naipes [x].valor[y] == "0"){
            y = rand () % 13;
        }
        
        t = naipes [x].valor[y];
        naipes [x].valor[y] = "0";
        
        if (i == 0){
            cout << "Jogador 1" << endl;
        }
        
        if (i == 5){
            cout << endl;
            cout << "Jogador 2" << endl;
        }

        cout << t << " de ";
        cout << naipes [x].nome << endl;
    }    

    return 0;
}

Comentários:

Cuidado com o acesso de posições fora do escopo do "vector". Se um vetor tem 13 posições, a última posição é a "12". O módulo correto é "% 13" e não "% 14".

Não é necessário usar um vetor auxiliar (conforme a linha deixada como comentário), pois é possível acessar a posição de cada elemento do vetor do registro por meio do par de colchetes.



